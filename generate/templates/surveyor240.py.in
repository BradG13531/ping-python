#!/usr/bin/env python3

# surveyor240.py
# A device API for the Cerulean Sonar Surveyor240 scanning sonar

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import time
from datetime import datetime, timezone
import struct
import socket

class Surveyor240(PingDevice):
    def initialize(self):
        if (self.readDeviceInformation() is None):
            return False
        return True

{% for msg in messages["get"]|sort %}
    ##
    # @brief Get a {{msg|replace("get_", "")}} message from the device\n
    # Message description:\n
    # {{messages["get"][msg].description}}
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
{% for field in messages["get"][msg].payload %}
    # {{field.name}}: {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}\n
{% endfor%}
    def get_{{msg}}(self):
        if self.request(definitions.SURVEYOR240_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
{% for msg in messages["set"]|sort %}
    ##
    # @brief Send a {{msg}} message to the device\n
    # Message description:\n
    # {{messages["set"][msg].description}}\n
    # Send the message to write the device parameters, then read the values back from the device\n
    #
{% for field in messages["set"][msg].payload %}
    # @param {{field.name}} - {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
    #
    # @return If verify is False, True on successful communication with the device. If verify is False, True if the new device parameters are verified to have been written correctly. False otherwise (failure to read values back or on verification failure)
    def {{msg}}(self{% for field in messages["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        m = pingmessage.PingMessage(definitions.SURVEYOR240_{{msg|upper}})
{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)
        if self.request(definitions.SURVEYOR240_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["set"][msg].payload %}
                and ({% for field in messages["set"][msg].payload %}self._{{field.name}} != {{field.name}}{{ " or " if not loop.last }}{% endfor %})):
{% endif %}
            return False
        return True  # success{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

{% for msg in messages["control"]|sort %}
    def control_{{msg}}(self{% for field in messages["control"][msg].payload %}, {{field.name}}{% if field.default is defined %}={{field.default}}{% endif %}{% endfor %}):
        m = pingmessage.PingMessage(definitions.SURVEYOR240_{{msg|upper}})
{% for field in messages["control"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

    def readDeviceInformation(self):
        return self.request(definitions.COMMON_DEVICE_INFORMATION)

    def get_utc_time(self):
        clock_offset = 0
        round_trip_delay = 5000

        local_now = datetime.now(timezone.utc)
        corrected_time = local_now.timestamp() * 1000 + clock_offset / 2
        accuracy = round_trip_delay / 2

        utc_msec_u64 = int(corrected_time) & 0xFFFFFFFFFFFFFFFF
        accuracy_msec = int(accuracy) & 0xFFFFFFFF

        return utc_msec_u64, accuracy_msec

    # Override handle_message to respond to a UTC request from Surveyor
    def handle_message(self, msg):
        if msg.message_id == definitions.SURVEYOR240_UTC_REQUEST:
            now, accuracy = self.get_utc_time()

            response = pingmessage.PingMessage(definitions.SURVEYOR240_UTC_RESPONSE)
            response.utc_msec = now
            response.accuracy_msec = accuracy
            response.pack_msg_data()
            self.write(response.msg_data)

            return True
        
        return super().handle_message(msg)
            
    # Override wait_message to also handle UTC requests from Surveyor and for creating atof_t data
    def wait_message(self, message_ids, timeout=0.5):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if msg.message_id == definitions.SURVEYOR240_UTC_REQUEST:
                    continue
                
                if msg.message_id == definitions.SURVEYOR240_ATOF_POINT_DATA:
                    atof_byte_array = bytearray(msg.atof_point_data)
                    formatted_atof_array = struct.unpack('<' + 'I' * (4*int(msg.num_points)), atof_byte_array)
                    msg.atof_point_data = formatted_atof_array

                if msg.message_id in message_ids:
                    return msg
            time.sleep(0.005)
        return None

    ##
    # @brief Do the connection via an TCP link
    #
    # @param host: TCP server address (IPV4) or name
    # @param port: port used to connect with server
    #
    def connect_tcp(self, host: str = None, port: int = 12345):
        if host is None:
            host = '0.0.0.0'
        
        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)
        
        except Exception as exception:
            raise Exception("Failed to open the given TCP port: {0}".format(exception))

    ##
    # @brief Read available data from the io device
    def read_io(self):
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            buffer_size = 4096
            while True:
                try: # Check if we are reading before closing a connection
                    bytes = self.iodev.recv(buffer_size)

                    if not bytes:
                        # if recv() returns empty, connection is closed (TCP)
                        if self.iodev.type == socket.SOCK_STREAM:
                            raise ConnectionError("TCP connection closed by peer.")

                    self._input_buffer.extendleft(bytes)

                    if len(bytes) < buffer_size:
                        break

                except BlockingIOError as exception:
                    pass # Ignore exceptions related to read before connection, a result of UDP nature
                
                except ConnectionResetError as e:
                    raise ConnectionError("Socket connection was reset: %s" % str(e))       

    # Class to represent the atof_t struct
    class atof_t:
        def __init__(self, angle=0.0, tof=0.0, reserved=(0,0)):
            self.angle = angle
            self.tof = tof
            self.reserved = reserved

        def __repr__(self):
            return f"angle: {self.angle}, tof: {self.tof}"

    # Creates atof_t[] and fills it with structured atof_ts using data from the message
    @staticmethod
    def create_atof_list(msg):
        raw_array = msg.atof_point_data

        atof_list = []
        for i in range(msg.num_points):
            idx = i * 4

            angle = struct.unpack('<f', struct.pack('<I', raw_array[idx]))[0]
            tof = struct.unpack('<f', struct.pack('<I', raw_array[idx + 1]))[0]
            reserved = (raw_array[idx + 2], raw_array[idx + 3])

            atof = Surveyor240.atof_t(angle, tof, reserved)
            atof_list.append(atof)
        
        return tuple(atof_list)

    # Creates yz_point_data and fills it with the correct data from the message
    @staticmethod
    def create_yz_point_data(msg):
        raw_array = msg.yz_point_data

        yz_list = struct.unpack('<' + 'f' * int(msg.num_points) * 2, raw_array)
        return yz_list


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Surveyor IP:Port. E.g: 192.168.2.86:62312")
    args = parser.parse_args()
    if args.device is None and args.udp is None and args.tcp is None:
        parser.print_help()
        exit(1)

    p = Surveyor240()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))
    elif args.tcp is not None:
        (host, port) = args.tcp.split(':')
        p.connect_tcp(host, int(port))

    print("Initialized: %s" % p.initialize())
    if p.iodev:
        try:
            p.iodev.close()
        except Exception as e:
            print(f"Failed to close socket: {e}")