#!/usr/bin/env python3

# s500.py
# A device API for the Cerulean Sonar S500 sonar

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import time
import struct
import socket

class S500(PingDevice):
    def initialize(self):
        if (self.readDeviceInformation() is None):
            return False
        return True

{% for msg in messages["get"]|sort %}
    ##
    # @brief Get a {{msg|replace("get_", "")}} message from the device\n
    # Message description:\n
    # {{messages["get"][msg].description}}
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
{% for field in messages["get"][msg].payload %}
    # {{field.name}}: {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}\n
{% endfor%}
    def get_{{msg}}(self):
        if self.request(definitions.S500_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
{% for msg in messages["set"]|sort %}
    ##
    # @brief Send a {{msg}} message to the device\n
    # Message description:\n
    # {{messages["set"][msg].description}}\n
    # Send the message to write the device parameters, then read the values back from the device\n
    #
{% for field in messages["set"][msg].payload %}
    # @param {{field.name}} - {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
    #
    # @return If verify is False, True on successful communication with the device. If verify is False, True if the new device parameters are verified to have been written correctly. False otherwise (failure to read values back or on verification failure)
    def {{msg}}(self{% for field in messages["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        m = pingmessage.PingMessage(definitions.S500_{{msg|upper}})
{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)
        if self.request(definitions.S500_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["set"][msg].payload %}
                and ({% for field in messages["set"][msg].payload %}self._{{field.name}} != {{field.name}}{{ " or " if not loop.last }}{% endfor %})):
{% endif %}
            return False
        return True  # success{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

{% for msg in messages["control"]|sort %}
    def control_{{msg}}(self{% for field in messages["control"][msg].payload %}, {{field.name}}{% if field.default is defined %}={{field.default}}{% endif %}{% endfor %}):
        m = pingmessage.PingMessage(definitions.S500_{{msg|upper}})
{% for field in messages["control"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

    def readDeviceInformation(self):
        return self.request(definitions.COMMON_DEVICE_INFORMATION)

    ##
    # @brief Do the connection via an TCP link
    #
    # @param host: TCP server address (IPV4) or name
    # @param port: port used to connect with server
    #
    def connect_tcp(self, host: str = None, port: int = 12345):
        if host is None:
            host = '0.0.0.0'
        
        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)
        
        except Exception as exception:
            raise Exception("Failed to open the given TCP port: {0}".format(exception))

    ##
    # @brief Read available data from the io device
    def read_io(self):
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            buffer_size = 4096
            while True:
                try: # Check if we are reading before closing a connection
                    bytes = self.iodev.recv(buffer_size)
                    if not bytes:
                        # if recv() returns empty, connection is closed (TCP)
                        if self.iodev.type == socket.SOCK_STREAM:
                            raise ConnectionError("TCP connection closed by peer.")

                    self._input_buffer.extendleft(bytes)

                    if len(bytes) < buffer_size:
                        break

                except BlockingIOError as exception:
                    pass # Ignore exceptions related to read before connection, a result of UDP nature
                
                except ConnectionResetError as e:
                    raise ConnectionError("Socket connection was reset: %s" % str(e))       

    # Converts power results to correct format
    @staticmethod
    def scale_power(msg):
        scaled_power_results = []
        for i in range(len(msg.pwr_results)):
            scaled_power_results.append(msg.min_pwr_db + (msg.pwr_results[i] / 65535.0) * (msg.max_pwr_db - msg.min_pwr_db))
        final_power_results = tuple(scaled_power_results)
        return final_power_results

    # Override wait_message to format power results before returning
    def wait_message(self, message_ids, timeout=0.5):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if (msg.message_id == definitions.S500_PROFILE6_T):
                        power_byte_array = bytearray(msg.pwr_results)
                        power_results = struct.unpack('<' + 'H' * int(msg.num_results), power_byte_array)
                        msg.pwr_results = power_results

                if msg.message_id in message_ids:
                    return msg
            time.sleep(0.005)
        return None

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Sounder IP:Port. E.g: 192.168.2.86:51200")
    args = parser.parse_args()
    if args.device is None and args.udp is None and args.tcp is None:
        parser.print_help()
        exit(1)

    p = S500()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))
    elif args.tcp is not None:
        (host, port) = args.tcp.split(':')
        p.connect_tcp(host, int(port))

    print("Initialized: %s" % p.initialize())
    if p.iodev:
        try:
            p.iodev.close()
        except Exception as e:
            print(f"Failed to close socket: {e}")