#!/usr/bin/env python3

# omniscan450.py
# A device API for the Cerulean Sonar Omniscan 450 sonar

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import time
import math
import struct
import socket
from datetime import datetime
from pathlib import Path

MAX_LOG_SIZE_MB = 500

class Omniscan450(PingDevice):
    def __init__(self, logging = False, log_directory = None):
        super().__init__()
        self.logging = logging
        self.log_directory = log_directory
        self.bytes_written = None
        self.current_log = None
        if logging:
            self.new_log(log_directory)

    def initialize(self):
        if (self.readDeviceInformation() is None):
            return False
        return True

{% for msg in messages["get"]|sort %}
    ##
    # @brief Get a {{msg|replace("get_", "")}} message from the device\n
    # Message description:\n
    # {{messages["get"][msg].description}}
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
{% for field in messages["get"][msg].payload %}
    # {{field.name}}: {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}\n
{% endfor%}
    def get_{{msg}}(self):
        if self.request(definitions.OMNISCAN450_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
{% for msg in messages["set"]|sort %}
    ##
    # @brief Send a {{msg}} message to the device\n
    # Message description:\n
    # {{messages["set"][msg].description}}\n
    # Send the message to write the device parameters, then read the values back from the device\n
    #
{% for field in messages["set"][msg].payload %}
    # @param {{field.name}} - {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
    #
    # @return If verify is False, True on successful communication with the device. If verify is False, True if the new device parameters are verified to have been written correctly. False otherwise (failure to read values back or on verification failure)
    def {{msg}}(self{% for field in messages["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        m = pingmessage.PingMessage(definitions.OMNISCAN450_{{msg|upper}})
{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)
        if self.request(definitions.OMNISCAN450_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["set"][msg].payload %}
                and ({% for field in messages["set"][msg].payload %}self._{{field.name}} != {{field.name}}{{ " or " if not loop.last }}{% endfor %})):
{% endif %}
            return False
        return True  # success{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

{% for msg in messages["control"]|sort %}
    def control_{{msg}}(self{% for field in messages["control"][msg].payload %}, {{field.name}}{% if field.default is defined %}={{field.default}}{% endif %}{% endfor %}):
        m = pingmessage.PingMessage(definitions.OMNISCAN450_{{msg|upper}})
{% for field in messages["control"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

    def readDeviceInformation(self):
        return self.request(definitions.COMMON_DEVICE_INFORMATION)

    # Calculate the milliseconds per ping from a ping rate
    @staticmethod
    def calc_msec_per_ping(ping_rate):
        return math.floor(1000.0 / ping_rate)

    # Calculate pulse length percent from percent value
    @staticmethod
    def calc_pulse_length_pc(percent):
        if percent > 0:
            return 0.01 * percent
        else:
            return 1.5 / 1200

    # Converts power results to correct format
    @staticmethod
    def scale_power(msg):
        scaled_power_results = []
        for i in range(len(msg.pwr_results)):
            scaled_power_results.append(msg.min_pwr_db + (msg.pwr_results[i] / 65535.0) * (msg.max_pwr_db - msg.min_pwr_db))
        final_power_results = tuple(scaled_power_results)
        return final_power_results

    # Creates a new log file
    def new_log(self, log_directory=None):
        dt = datetime.now()
        save_name = dt.strftime("%Y-%m-%d-%H-%M")
        
        if log_directory is None:
            project_root = Path.cwd().parent
            log_directory = project_root / "logs/omniscan"
        else:
            log_directory = Path(log_directory)

        log_directory.mkdir(parents=True, exist_ok=True)

        log_path = log_directory / f"{save_name}.svlog"

        if log_path.exists():
            raise FileExistsError(f"Log file already exists: {log_path}")

        self.current_log = log_path
        self.bytes_written = 0

    # Write data to .svlog file
    def write_data(self, msg):
        if not self.logging:
            return
        
        if self.bytes_written > MAX_LOG_SIZE_MB * 1000000:
            self.new_log(log_directory=self.log_directory)

        with open(self.current_log, 'ab') as f:
            f.write(msg.msg_data)
            self.bytes_written += len(msg.msg_data)

    # Override wait_message to format power results before returning
    def wait_message(self, message_ids, timeout=0.5):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if msg.message_id == definitions.OMNISCAN450_OS_MONO_PROFILE:
                    power_byte_array = bytearray(msg.pwr_results)
                    power_results = struct.unpack('<' + 'H' * int(msg.num_results), power_byte_array)
                    msg.pwr_results = power_results

                if msg.message_id in message_ids:
                    if self.logging:
                        self.write_data(msg)
                    return msg
            time.sleep(0.005)
        return None

    ##
    # @brief Do the connection via an TCP link
    #
    # @param host: TCP server address (IPV4) or name
    # @param port: port used to connect with server
    #
    def connect_tcp(self, host: str = None, port: int = 12345):
        if host is None:
            host = '0.0.0.0'
        
        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)
        
        except Exception as exception:
            raise Exception("Failed to open the given TCP port: {0}".format(exception))

    ##
    # @brief Read available data from the io device
    def read_io(self):
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            buffer_size = 4096
            while True:
                try: # Check if we are reading before closing a connection
                    bytes = self.iodev.recv(buffer_size)

                    if not bytes:
                        # if recv() returns empty, connection is closed (TCP)
                        if self.iodev.type == socket.SOCK_STREAM:
                            raise ConnectionError("TCP connection closed by peer.")

                    self._input_buffer.extendleft(bytes)

                    if len(bytes) < buffer_size:
                        break

                except BlockingIOError as exception:
                    pass # Ignore exceptions related to read before connection, a result of UDP nature
                
                except ConnectionResetError as e:
                    raise ConnectionError("Socket connection was reset: %s" % str(e))

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Omniscan IP:Port. E.g: 192.168.2.92:51200")
    args = parser.parse_args()
    if args.device is None and args.udp is None and args.tcp is None:
        parser.print_help()
        exit(1)

    p = Omniscan450()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))
    elif args.tcp is not None:
        (host, port) = args.tcp.split(':')
        p.connect_tcp(host, int(port))

    print("Initialized: %s" % p.initialize())

    if p.iodev:
        try:
            p.iodev.close()
        except Exception as e:
            print(f"Failed to close socket: {e}")